performance:
- i think there will be no anonymous variables
  to implement binder spilitting i will simply create new predicateliterals with their own domains
  if we have for example a predicate p(X,Y) where X is relevant and Y is irrelevant
  ill create a new predicate p(X) matching all p(X,_) thats easier and fits better into the current design
- literals in the body could be ordered by some heuristic see reference in dlv paper
- specialize domains for single/pair values this saves 12 bytes for each vector
  since values have a size of 8 bytes this could reduce the memory consumtion 
  of the memstress examples by 66% (but does it help in real world apps?)

code:
- write a better main app
- if a conflicting integrity constraint is found grounding could be stopped (and not just exit(0))
- use c++ exceptions
- fix the preprocessing for functionsymbols

documentation:
- write doxygen doc

propagation: (i think thats not that important)
- aggregates are always matched at the moment this could be improved
  (but this seems to not bother performance or program size)
  currently there is a negative dep added to a rule with an aggregate
  so every rule with aggregates belongs to a normal program
- the method isFact has to get an additional parameter if aggregates shall be matched

lparse compatibility:
- extend domain predicates currently no ;'s are allowed 
- improve handling of constants
- implement lparse like warnings
- the lparse preorder functions: plus, times, minus, ... are not supported
  only the infix functions: +, -, *, ... are supported
- lparse literals: lt, gt, ... are not supported
  only the infix literals: <=, >=, ... are supported

testing:
- write tests for all allowed language constructs !!!
- test conformance with lparse/gringo

smodelsoutput:
- the current smodelsoutput is a mess
  - there is no error handling using incompatible language constructs
    will result in strange behaviour => c++ exception should solve this
  - aggregates could be handled a bit better there are introduced a lot
    useless symbols in some cases (but thats not dramatically cause clasp's
    preprocessor seems to be able to remove them)
  - there is no distinction between COUNT and SUM aggregates (in case 
    there is no distinction at all every aggregate even MIN, MAX, ... is
    handled like a SUM aggregate :) )
    again it makes no difference for clasp if SUM or COUNT aggregates are
    used cause clasp will detect if all weights are 1
  - i believe that there is an easy transformation from MIN, MAX aggregates 
    to normalrules this transformation should be applied in the output

