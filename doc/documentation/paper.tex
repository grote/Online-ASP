\documentclass[a4paper,10pt]{article}

\usepackage[latin1]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{color}

\author{Max Ostrowski}
\title{Gringo 2.0}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\section{Introduction}
Answer Set Programming (ASP) \cite{baral02a} is a declarative approach for modeling and solving search problems, represented as logic programs.
An ASP system usually consists of a grounder and a solver.
First, a grounder translates a non-ground problem description into a propositional program, which can be processed by the second component of the system, the solver. This is illustrated in figure (\ref{fig:ASP}).
\begin{figure}[h]
\[
\xymatrix{*+[F]\txt{Problem\\representation}\ar[rr]^{Grounder}&&
		*+[F]\txt{Intermediate\\ representation} \ar[rr]^{Solver}&&
		*+[F]\txt{Variable\\ assignment}}
\]
\caption{Architecture of an ASP System}
\label{fig:ASP}
\end{figure}
gringo2.0 is a state of the art grounder and has many features that makes writing logic programs easy.
It was developed by Roland Kaminski and is orientated on the ideas of gringo1.0.
Therefore it supports binder splitting, backjumping and all other features already implemented in gringo1.0.\cite{gringopaper}
The goal of this work is to give an overview of the features supported by gringo2.0. A broad set of potentialities for writing encodings for logic programs exists. Currently, no other grounder supports such a rich featured language.
gringo2.0 supports several output formats and even a human readable format for debugging purposes.
It also has an internal interface to the solver clasp \cite{gekanesc07b}, so the output can directly be given to the solver and answer sets can be computed.
Furthermore gringo2.0 can be used with clasp incrementally. Detailed information about incremental solving can be found here \cite{gekaosscth08a} 
In this paper, at first, the general restrictions to the input language are stated. Then a brief description of how to use gringo2.0 is given.
In the next chapter the supported input language is described in detail and a short introduction of how to write a logic program is given. The paper closes with some examples of logic programs and gives an outlook of future work that has to be done in the area of grounding logic programs.
The syntax of the gringo2.0 input language can be found in the appendix \ref{appendix}.

\section{$\lambda$-Restriction}
\label{domainrestricted}
There exist two major grounders for ASP besides gringo1.0, lParse \cite{lparseManual} and  the DLV grounding module\cite{DLV}.
To ensure the existence of an equivalent ground instantiation of a program both grounders except a subclass of logic programs. For lParse the logic programs must be $\omega$-restricted\cite{omega} while DLV can handle safe programs\cite{safe}.
gringo2.0 verifies that the input program is $\lambda$-
restricted \cite{gringopaper}, so that the existence of a finite equivalent ground instantiation is guaranteed. 
$\lambda$-restrictedness extends the capabilities of $\omega$-restricted programs. The definition of $\lambda$-restrictedness can be found in \cite{gringopaper} and was expanded for aggregates and disjunctions.
$\lambda$-restrictedness can not be compared with the safe programs of DLV since there exist programs that are safe and not $\lambda$-restricted and vice versa.


\section{Using Gringo2.0}
\subsection{Command Line Interface}
gringo2.0 can be started from the command line and has some parameters that can be useful.
The first parameters are gringo2.0 specific parameters and consist of a number of options and any arbitrary number of filenames of the logic program. For the special purpose that gringo2.0 is used with its clasp module a double minus ``\texttt{--}'' is used to separate the clasp parameters from the gringo2.0 parameters.
If no filename is given, gringo2.0 reads from standard input.
\begin{verbatim}
 ./gringo (gringo option|file)* [--[ clasp options]]
\end{verbatim}
\subsection{Options}

\paragraph{\texttt{--help}}
Gives a short overview of all parameters.
\paragraph{\texttt{--const c=n}}
You can set the value of constants defined in your logic program via the command line of gringo2.0.
After the parameter ``--const'' you have to give the name of the constant $c$ you want to set followed by a ``$=$'' and the value of that constant. The integer value $n$ can even be an arithmetic expression. For example:
\begin{verbatim}
 gringo --const n=5*2
\end{verbatim}
the constant $c$ is replaced by $10$ in the logic program.

\paragraph{\texttt{--convert}}
If this parameter is used, the grounder expects an already grounded program as input.
For converting an already grounded logic program into an output format supported by gringo2.0 this is the right option. This mode saves a lot of memory but does not ground the program.
\paragraph{\texttt{-l}}
This mode prints smodels conform output. For a definition of the output format see \cite{lparseManual}.
Since some features of gringo2.0 are not natively supported for this output language, new atoms may be introduced to create an equivalent program.\newline
This is the current default output format of gringo2.0.
Sum aggregates with negative weights are handled like weight constraint in lparse for this output format. So a transformation as explained in \cite{lparseManual} is used to get rid of the negative weights.
\paragraph{\texttt{-c}}
In this mode, the output is directly parsed to clasp, an ASP solver. For solving logic programs, no intermediate files are produced and the answer sets are printed directly.
With this option enabled, all parameters for clasp are valid and can be declared in the command line. Therefore a double minus ``\texttt{--}'' must be given after all gringo2.0 related parameters are set. After them the clasp parameters follow.
For example:
\begin{verbatim}
 gringo -c --const n=5 -- --supp-models 3
\end{verbatim}
Furthermore all restriction on smodels output hold, as clasps internal interface currently reads smodels format.
\paragraph{\texttt{-p}}
Parameter ``\texttt{-p}'' invokes the plain output method, so the output is printed in human readable format, which is also the input format for gringo2.0. The output is variable free and some simplifications on the program were made. To convert the plain format into a format readable by a solver use the \texttt{--convert} option.
\paragraph{\texttt{-g [1-7]}}
This parameter invokes the new output format for the intermediate language ASPils \cite{gejaosscth08b}. The optional number can range from $1$ to $7$ and refers to one of the following normal forms (Simple=1, SModels=2, DisjunctiveLogicProgram=3, CModels=4, CModelsExtended=5, DLV=6, Conglomeration=7). If no normal form is specified, conglomeration(7)  is assumed.

\paragraph{Default Parameters}
The default command line is ``\texttt{./gringo -l}'' to read from standard input and for smodels output.

\subsection{Warnings}
Several warnings are produced by gringo2.0 to give hints on common mistakes.
They are all printed to standard error output.

\begin{itemize}
 \item 
\begin{verbatim}
 "Warning: sum with negative bounds in the body of a rule"
\end{verbatim}
This warning occurs if a sum aggregate with negative weights has been found and the output format smodels is used or the output is redirected to clasp. In this format negative bounds are compiled away using the transformation described in \cite{lparseManual}. This may lead to counterintuitive results.
 \item 
\begin{verbatim}
 "Warning: multiple definitions of #const n"
\end{verbatim}
This warning is printed if more than one \#const statement is used to set the same constant.
The last attached value is used for grounding.
\item
\begin{verbatim}
 "Warning: p/3 is never defined"
\end{verbatim}
This warnings states that an atom is used in the body of a rule that never occurs in the head.
The predicate literal is given in the warning. The predicate will be removed through optimization.
\item
\begin{verbatim}
 "got ground program i hope u have enough memory :)"
\end{verbatim}
Use the command line option ``--convert'' to convert a ground program into another format.
For converting already ground programs to an output language a special module has been implemented that uses far less memory. Because trying to ground an already variable free program could need a huge amount of memory.

\end{itemize}
Furthermore all warnings from clasp are included.

\subsection{Errors}
gringo2.0 stops the execution and prints an error message to standard error output.
\begin{itemize}
 \item 
\begin{verbatim}
 "the following rule cannot not be grounded,
  non domain predicates : { ... }"
\end{verbatim}
This error message gives a list of predicates that are not domain restricted.
You explicitly have to give a domain for those predicates.
 \item 
\begin{verbatim}
 "the following rule cannot not be grounded,
  weakly restricted variables: { ... }"
\end{verbatim}
This error message gives a list of variables that are not lambda restricted. 
\item
\begin{verbatim}
 "syntax error on line Y column Z unexpected token: X"
\end{verbatim}
The parser can not read the input format. Some unexpected token occurred in the input file.
\newline
\newline
The next errors all belong to the ASPils output format.
Some constructs in the input language can not be expressed in certain normal forms.
Another normal form as to be chosen to support this feature.
\begin{verbatim}
 "Disjunction not allowed on this normal form,
  please choose normal form 2 or 4-7."
 "Count aggregate/cardinality constraint not allowed
  in this normal form,
  please choose normal form 3-7."
 "Count aggregate/cardinality constraint not allowed 
  with non trivial upper bound in this normal form,
  please choose normal form 5-7."
 "Count aggregate/cardinality constraint not allowed 
  with negative lower bound in this normal form,
  please choose normal form 5-7."
 "Sum aggregate/weight constraint not allowed
  in this normal form,
  please choose normal form 3-7."
 "Sum aggregate/weight constraint not allowed 
  with non trivial upper bound in this normal form,
  please choose normal form 5-7."
 "Sum aggregate/weight constraint not allowed 
  with negative lower bound in this normal form,
  please choose normal form 5-7"
 "Sum aggregate/weight constraint not allowed
  with negative weights in this normal form,
  please choose normal form 5 or 7."
 "Max aggregate not allowed in this normal form,
  please choose normal form 6 or 7."
 "Max aggregate not allowed
  with negative weights in this normal form,
  please choose normal form 7."
 "Min aggregate not allowed in this normal form,
  please choose normal form 6 or 7."
 "Min aggregate not allowed 
  with negative weights in this normal form,
  please choose normal form 7."
 "Optimize statement not allowed in this normal form,
  please choose normal form 3-7."
\end{verbatim}
%\begin{verbatim}
% "Times aggregate not allowed in this normal form."
% "Times aggregate not allowed
%  with negative weights in this normal form."
%\end{verbatim}
\end{itemize}


\subsection{Building Gringo2.0 From Source}
For compiling gringo2.0, a binary version of ``re2c'' is needed to compile the lexer and the parser.
TODO: What about lemon.
As the build environment ``cmake'' is used.
TODO: How to build gringo2.0, clingo, iclingo etc...

\section{Syntax}
The basic elements of a logic program and its syntax is now described.
Disjunctive logic programs are based on an alphabet \cite{syntax} consisting of:
\begin{itemize}
\item a set $\mathcal{P}$ of predicate symbols,
\item a set $\mathcal{F}$ of function symbols,
\item a set $\mathcal{V}$ of variables,
\item a set $\mathcal{C}$ of constants,
\item a set \{ ``$\mid$'', ``,'' ,$\leftarrow$, not \} of connectives, and
\item a set \{ ``('', ``)'', ``,'' \} of punctuation symbols.
\end{itemize}

\paragraph{Predicates and Function Symbols}
Predicates and function symbols have a predicate symbol/name and an arity.
For the function symbol $f$ with arity 3 we write $f/3$.
The names of the function symbols and predicates have to start with either a lower case letter or an underscore and can contain digits and letters.
With $\mathcal{P}$ we denote to the set of predicates and $\mathcal{F}$ denotes the set of function symbols.
\paragraph{Constants}
Constants are function symbols with an arity of zero.
The name of a constant can also be encompassed by double quotation marks, which is sometimes helpful when using constants with spaces. It has to be remarked that a constant with quotation marks is never equal to a constant without, so ``\texttt{a}'' is not equal to \texttt{a}.
$\mathcal{C}$ is the set of constants.
\paragraph{Variables}
Variables have to start with a capitalized letter and can contain digits and letters.
The set of variables is denoted by $\mathcal{V}$.
The language over $\mathcal{P}$, $\mathcal{F}$ and $\mathcal{C}$ is denoted by $\mathcal{L(P,F,C)}$.
\paragraph{Terms}
The building blocks of the language are terms.
Each constant $c \in \mathcal{C}$ and each function symbol $f \in \mathcal{F}$ is a term.
Furthermore $f(t_1, \dots, t_n)$ is a term if $f/n \in \mathcal{F}$ and $t_i \mid i \in \{1 \dots n\}$ are terms.
Since a term is defined recursively, it can be nested.
A term with the first parameter being a constant $a$, the others being terms $f(b,X)$ and $g(f(X), Y))$ would be expressed this way.
\newline
TODO: This is not a term following the definition, it contains variables!!! Is a variable a Term ?
\begin{verbatim}
 p(a,f(b,X), g(f(X),Y)).
\end{verbatim}
\paragraph{Atoms}
An atom over $\mathcal{L(P, F, C)}$ is of the form $p(t_1, \dots, t_n)$ where $p/n$ is a predicate
symbol with arity $n$, and $t_i \mid i \in \{1 \dots n\}$ are terms.
\paragraph{Rules}
A rule over the language $\mathcal{L(P,F,C)}$ has the form
$$
A_0 \mid \dots \mid A_l \leftarrow A_{l+1}, \dots, A_m, not\ A_{m+1}, \dots, not\ A_n.
$$
where $A_0$ to $A_n$ are atoms. \newline
A logic program $\Pi$ over $\mathcal{L(P,F,C)}$ is a finite set of rules over $\mathcal{L(P,F,C)}$.

%\paragraph{Function Symbols}
%A constant is a representation of an entity in the problem domain.
%A constant is either a name, starting with a lower case letter or an underscore, or a positive integer.
%It also can be encompassed by double quotation marks. When using quotation marks, which is sometimes helpful when using %constants with spaces, it has to be remarked that a constant with quotation marks is never equal to a constant without, so ``$a$'' is not $a$.
%\paragraph{Variable}
%A variable is programming construct to simplify writing logic programs.
%It always starts with a capitalized letter and can contain digits and letters.
%In the grounding process a variable is replaced by one or more constants.
%Each variable occurring in a rule must be domain restricted as described in section \ref{domainrestricted}.
%\paragraph{Atom}
%An atom is a predicate with a name. The name can consist of letters, digits and the underscore.
%It has to start with a lower case letter or an underscore.
%An atom can have several parameters, encapsulated by parenthesis and separated with commas.
%The parameters are either constants, variables or function symbols.
%Function symbols do have the same syntax as atoms. This way they can be finitely nested.
%As an example, an atom with three parameters is given:
%The first parameter being a constant $a$, the others being function symbols $f(b,X)$ and $g(f(X), Y))$.
%\begin{verbatim}
% p(a,f(b,X), g(f(X),Y)).
%\end{verbatim}

%\paragraph{Rule}
%A rule normally consists of a head and a body and ends with a dot.
%The body is separated from the head using ``:-'' as in
%\begin{verbatim}
% head :- body.
%\end{verbatim}
%The body is a comma separated conjunction of expressions.
%The supported expressions are introduced in the next section.
%The variables used in the head must be restricted to a domain in the body.
%Check (\ref{domainrestricted}) to see the restrictions on domains.
%\newline
%A rule can occur without a body as a fact, therefore the body is omitted.
%\begin{verbatim}
% head.
%\end{verbatim}
%The same can be done with the body to express an integrity constraint.
%\begin{verbatim}
% :- body.
%\end{verbatim}

\subsection{How to Write a Logic Program}
Writing a logic program to solve a problem is rather describing a problem than describing an algorithm to solve a problem.
Therefore the problem must be encoded as a set of rules.
Typically these are divided into a problem description and an instance of the problem.
The solution to a problem can then be read from the answer sets of the program.
The procedure of writing a logic program shall now be explained with a little example.
We want to write a problem encoding for the 3-colorability problem of graph coloring.
Given an arbitrary graph, no two connected edges may have the same color.
The most common technique is the ``generate \& test'' approach. Therefore, in the generator, rules are created that can derive a superset of the solution to the problem. In the tester all solutions that do not fit the constraints are omitted.
\newline
Usually you start with the with the generator.
At first, we define the non instance domains, in our example the colors we use.
\begin{verbatim}
 color(red). color(green). color(blue).
\end{verbatim}
Now we have to color all the vertices, but we must give attention that each vertex has only one color.
We can do this by simply saying that a vertex is colored with one color $C$, and that the same vertex does not have any of the other colors $D$ or $E$.
\begin{verbatim}
 colored(V,C) :- not colored(V,D), not colored(V,E),
                 C != D, C != E, D != E,
                 color(E), color(C), color(D), vertex(V).
\end{verbatim}
As you can see, you have to give the domain of the variables in the rule.
The variable $V$ is used for vertices and the variables $C$, $D$ and $E$ are used for colors.
After every vertex now has a color we would get all possible solutions of all vertices colorfully painted.
We now need to restrict our solutions in the tester by saying that two vertices that are connected by an edge should not have the same color.
We can do this by using an integrity constraint.
An integrity constraint is a rule with an empty head, and if an assignment of variables fulfills the body, the assignment is not a solution of our problem.
\begin{verbatim}
 :- edge(V,U), colored(V,C), colored(U,C),
    vertex(V), vertex(U), color(C).
\end{verbatim}
Here we have the edge between two vertices $V$ and $U$, and if both are colored with the same color $C$ the assignment is not a solution to our problem.
\newline
We have finally written our problem description, all we need now is a problem instance. This step is fairly simple.
We just need to define several vertices and edges that do connect the vertices.
For the following simple graph
\[
 \xymatrix{1\ar@{-}[dr]\ar@{-}[d]\ar@{-}[r]&2\ar@{-}[dl]\\
           3&4}
\]

we could just write
\begin{verbatim}
 vertex(1..4).
 edge(1,2). edge(1,4).
 edge(3,1). edge(3,2).
\end{verbatim}

If we give the problem description and the instance to the grounder, it will generate a variable free version of the problem. This can then be solved by a solver and in the answer sets of the solver the ``\texttt{colored}'' predicate states a valid coloring of all vertices.
We can do this by simply using the internal interface to clasp, to get a solution.
\begin{verbatim}
 ./gringo -c 3colorability.lp instance1.lp
\end{verbatim}
In the first answer set we find the ``\texttt{colored}'' predicates
\begin{verbatim}
 colored(1,green) colored(2,red) colored(3,blue) colored(4,red)
\end{verbatim}
and we can interpret them as the colors of the vertices
 
\[
 \xymatrix{\color{green}1\ar@{-}[dr]\ar@{-}[d]\ar@{-}[r]&\color{red}2\ar@{-}[dl]\\
           \color{blue}3&\color{red}4}
\]

\subsection{Meta-Syntax}
This section is about constructs that do not originally belong to the logic program but can be used to give additional information for example to the solver.
The ``\#'' sign in front of all meta expressions is optional but is it strongly recommend to use it.
It separates the meta directives from the logic program more clearly and can prevent severe mistakes,
 confusing those constructs with atoms as shown in the example.
\begin{verbatim}
 hide.
 hidden :- hide.
\end{verbatim}
This program hides all predicates from the output of the ASP solver instead of deriving the facts \texttt{hide} and \texttt{hidden}.

\paragraph{hide}
The hide construct is used to hide atoms from the output of the ASP solver.
Two different syntaxes are supported by gringo2.0.
The first 
\begin{verbatim}
 #hide name/arity.
\end{verbatim}
and the second
\begin{verbatim}
 #hide name(X1, ... , Xn).
\end{verbatim}
Both variants hide the predicate ``\texttt{name}''.
The arity of the predicate can be given explicit or implicit with a list of variables.
The variables are just placeholder and do not unify with other variables. For example \texttt{hide p(X,X)} would also hide the fact \texttt{p(a,b)}. The second syntax is implemented for compatibility reasons only.
If the predicate that has to be hidden has arity zero the syntax is
\begin{verbatim}
 #hide name.
\end{verbatim}
If you want to express that all but a few predicates shall be hidden the empty hide statement
in conjunction with the ``\texttt{show}'' statement can be is used.
With ``\texttt{show}'' all predicates are named that shall be visible.
So to hide all predicates but $p/3$ the following example can be used.
\begin{verbatim}
 #hide.
 #show p/3.
\end{verbatim}

\paragraph{const}
Within the ``\texttt{const}'' statement, a default value for constants can be defined in the logic program.
while they are normally defined via the command line options.
A default value for a constant $n$ can be easily be set.
\begin{verbatim}
 #const n=5.
\end{verbatim}
\paragraph{domain}
A domain statement states that a specific variable has a global domain restriction.
The statement
\begin{verbatim}
 #domain time(T).
\end{verbatim}
makes sure that the variable ``\texttt{T}'' is always bound to the domain of ``\texttt{time}''.
This has the same effect as adding the domain ``\texttt{time(T)}'' to every rule the variable ``\texttt{T}'' occurs in.
\paragraph{compute}
The compute statement is a hint for the solver which models to compute.
It has the syntax
\begin{verbatim}
 #compute number {a1, ..., aN, not aN+1, ..., not aM}.
\end{verbatim}
$number$ is the number of models that shall be computed by the answer set solver and can be omitted. If it is zero, no restriction to the number of models is applied.
All positive atoms in the compute statement must be in the computed models, and all negated atoms do not have to be in the models of the program.
The compute statement is solver dependent and not supported by every solver.
\paragraph{comments}
Comments included in the input are line based.
Whenever a ``\texttt{\%}'' occurs in the input, the rest of the line is treated as a comment and is therefore omitted.



\subsection{Features}
To ease the process of writing logic programs some features in the input syntax are introduced and are now explained in detail.
For the most problems it is possible to write a much shorter version of the program with the extended syntax.
%Even a speedup in solving the instances of the problem can happen TODO ?
For a full syntax description in EBNF see appendix (\ref{appendix}).
\paragraph{Function Symbols}
Function symbols are fully supported with gringo2.0.
They can be finitely nested and also be used as domain predicates.
While in lParse function symbols are allowed in a very restricted way, no restrictions apply in gringo2.0.
The following program can not be grounded with lParse since $X$ is an unrestricted variable. With gringo2.0 the program is now groundable.
\begin{verbatim}
a(X) :- f(1,g(X)).
f(1,X) :- f(X).
f(g(2)).
\end{verbatim}
From the second rule the domain \texttt{f(1,g(2))} is generated.
This domain can be used for the first rule and results in the grounded rule
\begin{verbatim}
 a(2) :- f(1,g(2)).
\end{verbatim}

\paragraph{Range Operator}
To define several atoms that stretch on one or more parameters over a certain range, two dots can be used to express an increasing integer range.
Using the range operator in the head of a rule, it works as a conjunction of all the members in the range, so for every number the rule is duplicated.
\begin{verbatim}
 times(1..3, 1..2).
\end{verbatim}
will result in the facts
\begin{verbatim}
 times(1,1). times(2,1). times(3,1).
 times(1,2). times(2,2). times(3,2).
\end{verbatim}

Using the range operator in the body of a rule, a disjunction of all members in the range is created. So the rules will be duplicated for every member.
\begin{verbatim}
 a :- p(1..3).
\end{verbatim}
will result in the rules
\begin{verbatim}
 a :- p(1).
 a :- p(2).
 a :- p(3).
\end{verbatim}
If the range operator is used in an aggregate, it creates a comma separated list of atoms, so
\begin{verbatim}
 a :- {b(1..3)}.
\end{verbatim}
results in
\begin{verbatim}
 a :- {b(1), b(2), b(3)}.
\end{verbatim}

\paragraph{Expander :}
With the expander ``:'' a domain can be set.
On the left side of the operator an atom with variables is expected and on the right side the domains for the variables are given.
In the head, the atoms get connected via a disjunction, in the body they get connected via a conjunction, so no new rules are created with this operator.
\begin{verbatim}
 a(X,Y) : b(X) : c(Y) :- d(X) : e(X).
 b(1..2).
 c(3).
 e(a;b;c).
\end{verbatim}
would become
\begin{verbatim}
 a(1,3) | a(2,3) :- d(a), d(b), d(c).
\end{verbatim}
This operator can be used in aggregates to create a comma separated list of atoms.

\paragraph{Conjunctor ;}
The conjunctor ``;'' will create a conjunction of its elements.
Used in the head of a rule means that the rule is duplicated.
If used in the body instead, the atoms will be logically combined using a conjunction.
\begin{verbatim}
 a(X;1..2) :- b(X;a;b).
 b(foo). b(bar).
\end{verbatim}
will results in the rules\footnote{gringo2.0 would simplify the grounded rules since some literals in the body are facts}
\begin{verbatim}
 a(foo,1) :- b(foo), b(a), b(b).
 a(foo,2) :- b(foo), b(a), b(b).
 a(bar,1) :- b(bar), b(a), b(b).
 a(bar,2) :- b(bar), b(a), b(b).
\end{verbatim}
The conjunctor can not be used directly in aggregates, but for example in combination with the expander.
\begin{verbatim}
 { a(X,Y) : p(X;Y) }.
 p(1..2).
\end{verbatim}
Results in
\begin{verbatim}
 {a(1,1), a(1,2), a(2,1), a(2,2)}.
 p(1).
 p(2).
\end{verbatim}

\paragraph{Arithmetic Expressions}
The built-in arithmetics can be used for integer arithmetic.
As operators addition (+), subtraction (-), multiplication (*), division (/), modulo (mod) and the absolute value operator (abs) can be used.
Furthermore the bitwise operators and(\&), or(?), xor(\textasciicircum) and invert($\sim$) are supported. The bitwise operators are executed on signed integers using the binary complement for negative numbers.
Arithmetic expressions can occur everywhere in the head and in the body, even in complex constructs.
As parameters, integer constants or expressions that evaluate to integers are used.
The simple example of using operators and range terms
\begin{verbatim}
 a(X-1 .. X+1) :- b(X,Y), c(abs(Y * 2 * -X)).
 b(1,2).
 c(4).
\end{verbatim}
would result in the grounded program
\begin{verbatim}
 a(0) :- b(1,2), c(4).
 a(1) :- b(1,2), c(4).
 a(2) :- b(1,2), c(4).
 b(1,2).
 c(4).
\end{verbatim}

\subparagraph{Relational Operators}
The relational operators are ``less than'' ($<$),\\ ``greater than'' ($>$), ``less equal'' ($<=$), ``greater equal'' ($>=$) , ``equal'' ($==$) and ``not equal'' ($!=$).
They can be used to constrain certain variables.
For example, the following rule is only generated for all unifications where $X$ is greater or equal $Y-1$.
\begin{verbatim}
 a(X) :- b(X,Y), X >= Y-1.
 b(0,2).
 b(4,2).
\end{verbatim}
This would let $\texttt{b(4,2)}$ be a valid substitution, since $4 >= 2-1$ but $\texttt{b(0,2)}$ not, so the grounded program could be:
\begin{verbatim}
 a(4) :- b(4,2).
 b(0,2).
 b(4,2).
\end{verbatim}

\subparagraph{Assignment Operator}
As assignment operator ``$=$'' is used.
The variable on the left side is set to the value of the right side.
\begin{verbatim}
 a(X) :- X=Y*2, b(Y).
 b(1..2).
\end{verbatim}
becomes
\begin{verbatim}
 a(2) :- b(1).
 a(4) :- b(2).
 b(1..2).
\end{verbatim}
A cyclic assignment that results in an unbound variable is not allowed and is rejected with an error . For example
\begin{verbatim}
 a(X) :- X=Y, Y=X.
\end{verbatim}

\paragraph{Classical Negation}
For classical negation the atom is preceded by a minus sign.
\begin{verbatim}
 -a :- not  a.
  a :- not -a. 
\end{verbatim}
\paragraph{Disjunction}
A disjunction can be expressed using the pipe symbol ``$\mid$''.
A disjunction can only occur in the head of a rule.
\begin{verbatim}
 red | green | blue :- colored.
\end{verbatim}
Using disjunctions in logic programs can increase expressiveness and complexity of the logic program.
A solver for disjunctive logic programs such as claspD \cite{claspD} or cmodels \cite{cmodels} is needed to solve such programs.

\paragraph{Aggregates}
An aggregate is a set or a multiset of atoms and has a lower and an upper bound.
The general syntax is
\begin{verbatim}
 lower aggregate_name [atom1=w1, ..., atomN=wN] upper
\end{verbatim}
If squared brackets are used, the atom list is interpreted as a set, otherwise, for curly brackets, as a multiset of atoms.
The lower and upper bound is optional, and can be omitted.

\subparagraph{Count}
A ``count'' aggregate is a set of atoms and has an optional lower and upper bound.
It evaluates to true if the number of true atoms in the set is between the lower and upper bound. Only curly brackets may be used for a count aggregate as it represents a set of atoms.
Weights are not allowed in the count aggregate.
For this aggregate a shorthand syntax exists
\begin{verbatim}
 lower {atom1, ..., atomN} upper
\end{verbatim}
The count aggregate is equal to the cardinality constraint known from smodels \cite{smodels}.
\subparagraph{Sum}
The ``sum'' aggregate is a multiset of weighted atoms and has an optional lower and upper bound. It evaluates to true if the sum of the weights of all true atoms in the multiset is between the lower an upper bound.
The sum aggregate is equal to the weight constraints known from smodels, and has therefore a shorthand syntax
\begin{verbatim}
 lower [atom1=w1, ..., atomN=wN] upper
\end{verbatim}
If the command line option ``-l'' is used the semantic may change if negative weights exist in the aggregate. The transformation used is described in \cite{lparseManual}.

\subparagraph{Min}
The ``min'' aggregate is determined by the minimum of all weights of atoms that evaluate to true.
For the minimum aggregate a multiset with weighted atoms is used. It has no shorthand syntax.
\subparagraph{Max}
The ``max'' aggregate is similar to the minimum aggregate but considers the maximum of the weights.

\paragraph{Optimize Statements}

\subparagraph{Minimize/Maximize}
An optimize statement is used to find a minimal or maximal answer set of the logic program.
The statement can be weighted or not, therefore weights can be omitted in the following syntax.
\begin{verbatim}
 minimize [atom1 = w1, ..., atomN = wN].
\end{verbatim}
The maximize statement uses the keyword ``maximize'' instead.
If there were several minimize/maximize statements in the logic program the latter will be preferenced.
Only after the n'th statement results in the same value for two different answer set, the n-1'th statement is considered.


\section{Examples}
In this section some encodings for common problems are presented and explained.
\paragraph{Fastfood}
This example needs a proper instance to work.
\begin{verbatim}
#hide.
#show altdepot/2.
#show costs/1.

% calculate the number of depots
depots(X) :- X = { depot(DN, DK) :  depot(DN, DK) }.

% calculate the costs for the initial depots
% (the grounder can calculate this on its own)
costs(C) :- C = [ serves(RN, Dist) : restaurant(RN, RK) : dist(Dist) = Dist ].

% choose the closest depot for a restaurant
% (the grounder can calculate this on its own)
serves(Rname,Dist) :- restaurant(Rname,RK),
   Dist = min [ depot(DN1, DK1) : depot(DN1, DK1) = abs(DK1-RK) ].

dist(abs(X-Y)) :- restaurant(A, X), restaurant(B, Y).

% Each restaurant may be an alternative depot or not.
X { altdepot(R,K) : restaurant(R,K) } X :- depots(X).

% choose the closest depot for a restaurant
altserves(Rname,Dist) :- restaurant(Rname,RK),
   Dist = min [ altdepot(DN1, DK1) : restaurant(DN1, DK1) = abs(DK1-RK) ].

% fail if we have not found a better solution
:- costs(C), C [ altserves(R,Dist) : dist(Dist) : restaurant(R,RK) = Dist ].

% thats the easiest way to show the calculated costs
minimize [ altserves(R,Dist) : dist(Dist) : restaurant(R,RK) = Dist ].
\end{verbatim}

\paragraph{Queens}
\begin{verbatim}
#hide.
#show q(X,Y).

% this can be set via the command line
#const queens = 200.

#const diags  = queens * 2 - 1.
d(1..queens).
diag(1..diags).

% enumerate the diagonals
diagX(X,Y,X - Y + queens) :- d(X), d(Y).
diagY(X,Y,X + Y - 1) :- d(X), d(Y).

% exactly 1 queen in each row/col
1 { q(X,Y) : d(Y) } 1 :- d(X).
1 { q(X,Y) : d(X) } 1 :- d(Y).

% at most 1 queen on each diagonal
{ q(X,Y) : diagX(X,Y,D) } 1 :- diag(D).
{ q(X,Y) : diagY(X,Y,D) } 1 :- diag(D).

\end{verbatim}

%\section{Benchmarks}
%The benchmarks were run on an Athlon XP 1700+ with 1GB of RAM.
%TODO: Official (non internal wiki) link to the instances.

%\input{benchmark2.result}
\section{Future Work}
Further research has to be done on features in the input language. Additionally the support of incremental grounding will be improved. To speed up the grounding process research on a bottom up grounding procedure is done. To support an even less restricted input language the support for $\Pi$-restricted programs is planned in a future release of gringo. All these features will lead to more acceptance of ASP-systems as the programs become easier to write and the bottleneck of ASP, the grounding part, will be faster.
Furthermore the acceptance of a standardized intermediate format for ASP is necessary. gringo2.0 supports the ASPils output format, but many more tools for converting, shuffling and merging must be developed.
\newpage
\textbf{\appendixname}
\begin{appendix}
\section{EBNF Syntax}
\label{appendix}
\input{appendix}
\end{appendix}

\bibliographystyle{plain}
\bibliography{bibtex}
\appendix
%todo: input grammar in EBNF
\end{document}
