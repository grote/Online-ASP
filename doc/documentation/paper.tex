\documentclass[a4paper,10pt]{article}

\usepackage[latin1]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{color}
\usepackage[nofancy]{svninfo}
%\usepackage{comments}



\author{Martin Gebser, Roland Kaminski, Benjamin Kaufmann,\\ Max Ostrowski, Torsten Schaub, Sven Thiele}
\title{Using gringo, clingo and iclingo
\\\small{Rev.\svnInfoRevision}
}
\date{\today}

\begin{document}
\svnInfo $Id$
\maketitle
%\begin{center}\stamp\end{center}
%\includecomment{comment}
%\excludecomment{notthisone}

\abstract{}
This paper introduces the new tools gringo, clingo and iclingo of the potassco project\cite{download}.
Since the variety of programs for grounding logic programs with first order logic variables is low, a new grounding front-end for ASP was developed. This front-end called gringo, has a well defined input language described in this paper and outdoes former approaches in speed, memory consumption and usability.
Clingo is a compound of gringo and clasp, a full blown answerset solver.
Iclingo is a program capable of incremental solving.
All three tools are introduced and their use is recorded.

\tableofcontents
\section{Introduction}
Answer Set Programming (ASP) \cite{baral02a} is a declarative approach for modeling and solving search problems, represented as logic programs.
An ASP system usually consists of a grounder and a solver.
First, a grounder translates a non-ground problem description into a propositional program, which can be processed by the second component of the system, the solver. This is illustrated in figure (\ref{fig:ASP}).
\begin{figure}[h]
\[
\xymatrix{*+[F]\txt{Problem\\representation}\ar[rr]^{Grounder}&&
		*+[F]\txt{Intermediate\\ representation} \ar[rr]^{Solver}&&
		*+[F]\txt{Variable\\ assignment}}
\]
\caption{Architecture of an ASP System}
\label{fig:ASP}
\end{figure}
Gringo is a state of the art grounder and has many features that makes writing logic programs easy.
It was developed by Roland Kaminski and is orientated on the ideas of gringo1.0.0\cite{gringopaper}.
Therefore it supports binder splitting, backjumping and all other features already implemented in gringo1.0.0.
A broad set of potentialities for writing encodings for logic programs exists. Currently, no other grounder supports such a rich featured language.
The goal of this work is to give an overview of the features supported by gringo and its derivates.
Three different packages of gringo exist.
The first version is gringo, it acts as a grounder and supports several output formats and even a human readable format for debugging purposes. This version can ground logic programs and output them to files or pipe them to a solver.
The second version is called clingo and is a grounder with a built-in solver clasp \cite{gekanesc07b}.
Output can directly be given to the solver and answer sets can be computed.
The third package is called iclingo, which stands for ``incremental clingo''. In this version the grounder gringo can be used with clasp incrementally. Detailed information about incremental solving can be found in \cite{gekaosscth08a}.
In this paper, at first, the general restrictions to the input language are stated and the supported input language is described in detail. After that, a short introduction of how to write a logic program and how to write an incremental logic program is given. In the next chapter a brief description of how to use the three programs gringo, clingo and iclingo and their options for the command line is given. The paper closes with an outlook of future work that has to be done in the area of grounding logic programs.
The syntax of the gringo input language can be found in the appendix \ref{appendix}.
\paragraph{Versions}
This paper references the programs with the following version numbers:
\begin{itemize}
 \item \texttt{gringo\ \ 2.0.0}
 \item \texttt{clingo\ \ 1.0.0}
 \item \texttt{iclingo\ 1.0.0}
\end{itemize}



\section{Syntax}
The basic elements of a logic program and its syntax is now described.
Disjunctive logic programs are based on an alphabet \cite{syntax} consisting of:
\begin{itemize}
\item a set $\mathcal{P}$ of predicate symbols,
\item a set $\mathcal{F}$ of function symbols,
\item a set $\mathcal{V}$ of variables,
\item a set $\mathcal{C}$ of constants,
\item a set \{ ``$\mid$'', ``,'' ,$\leftarrow$, not \} of connectives, and
\item a set \{ ``('', ``)'', ``,'' \} of punctuation symbols.
\end{itemize}

\paragraph{Predicates and Function Symbols}
Predicates and function symbols have a predicate symbol/name and an arity.
For the function symbol $f$ with arity 3 we write $f/3$.
The names of the function symbols and predicates have to start with either a lower case letter or an underscore and can contain digits and letters.
With $\mathcal{P}$ we denote to the set of predicates and $\mathcal{F}$ denotes the set of function symbols.
\paragraph{Constants}
Constants are function symbols with an arity of zero.
The name of a constant can also be encompassed by double quotation marks, which is sometimes helpful when using constants with spaces. It has to be remarked that a constant with quotation marks is never equal to a constant without, so ``\texttt{a}'' is not equal to \texttt{a}.
$\mathcal{C}$ is the set of constants.
\paragraph{Variables}
Variables have to start with a capitalized letter and can contain digits and letters.
The set of variables is denoted by $\mathcal{V}$.
The language over $\mathcal{P}$, $\mathcal{F}$ and $\mathcal{C}$ is denoted by $\mathcal{L(P,F,C)}$.
\paragraph{Terms}
The building blocks of the language are terms.
Each variable $v \in \mathcal{V}$, constant $c \in \mathcal{C}$ and each function symbol $f \in \mathcal{F}$ is a term.
Furthermore $f(t_1, \dots, t_n)$ is a term if $f/n \in \mathcal{F}$ and $t_i$ for $i \in \{1 \dots n\}$ are terms.
Since a term is defined recursively, it can be nested.
A term with the first parameter being a constant $a$, the others being terms $f(b,X)$ and $g(f(X), Y)$ would be expressed this way.
\begin{verbatim}
 p(a,f(b,X), g(f(X),Y)).
\end{verbatim}
\paragraph{Atoms}
An atom over $\mathcal{L(P, F, C)}$ is of the form $p(t_1, \dots, t_n)$ where $p/n$ is a predicate
symbol with arity $n$, and $t_i$ for $i \in \{1 \dots n\}$ are terms.
\paragraph{Rules}
A rule over the language $\mathcal{L(P,F,C)}$ has the form
$$
A_0 \mid \dots \mid A_l \leftarrow A_{l+1}, \dots, A_m, not\ A_{m+1}, \dots, not\ A_n.
$$
where $A_0$ to $A_n$ are atoms. \newline
A logic program $\Pi$ over $\mathcal{L(P,F,C)}$ is a finite set of rules over $\mathcal{L(P,F,C)}$.

\subsection{$\lambda$-Restriction}
\label{domainrestricted}
There exist two major grounders for ASP besides gringo, lParse \cite{lparseManual} and  the DLV grounding module\cite{DLV}.
To ensure the existence of an equivalent ground instantiation of a program both grounders except a subclass of logic programs. For lParse the logic programs must be $\omega$-restricted\cite{omega} while DLV can handle safe programs\cite{safe}.
Gringo verifies that the input program is $\lambda$-
restricted \cite{gringopaper}, so that the existence of a finite equivalent ground instantiation is guaranteed. 
$\lambda$-restrictedness extends the capabilities of $\omega$-restricted programs. The definition of $\lambda$-restrictedness can be found in \cite{gringopaper} and was expanded for aggregates and disjunctions.
$\lambda$-restrictedness can not be compared with the safe programs of DLV since there exist programs that are safe and not $\lambda$-restricted and vice versa.
\newline
To give a gross impression of what $\lambda$-restriction means for writing a logic program an informal description is given.
In gringo every variable used in a rule must have a complete domain. This means that this variable has to occur in at least one predicate whose domain is completed. Therefore the predicate must be in the head of rules that are already domain restricted. So the grounder has to find a valid order of the rules so that every predicate in the head is completed before it is used as a domain predicate for the next rules.
To make things more clear, an example is given
\begin{verbatim}
 zig(0) :- not zag(0).   zag(0) :- not zig(0).
 zig(1) :- not zag(1).   zag(1) :- not zig(1).
 zigzag(X,Y) :- zig(X), zag(Y).
\end{verbatim}
The rules of this example can be ordered in the following way.
At first, the rules with \texttt{zig/1} and \texttt{zag/1} are considered.
Since these are the only rules \texttt{zig/1} and \texttt{zag/1} occurs in the head, the domains of the predicates are closed. The domains \{\texttt{zig(0)}, \texttt{zig(1)}\} and \{ \texttt{zag(0)}, \texttt{zag(1)}\} are complete, since no other predicates of the form \texttt{zig/1} or \texttt{zag/1} can be derived from the program.
Now the third rule with \texttt{zigzag/2} in the head can be grounded. The variables \texttt{X} and \texttt{Y} both occur in a domain predicate, and the values $0$ respectively $1$ can substitute the variables.
\newline
To give a comparison to the $\omega$-restricted programs of lParse, an extra domain predicate has to be introduced to the example.
\begin{verbatim}
 domain(0..1).
 zig(0) :- not zag(0).   zag(0) :- not zig(0).
 zig(1) :- not zag(1).   zag(1) :- not zig(1).
 zigzag(X,Y) :- zig(X), zag(Y), domain(X), domain(Y).
\end{verbatim}
\texttt{zig/1} and \texttt{zag/1} can not be used as a domain predicate, since their truth value can not be fully evaluated.

\subsection{Basic Language}
The base building blocks of the language are rules, facts and integrity constraints.
\paragraph{Rule}
A rule normally consists of a head and a body and ends with a dot.
The body is separated from the head using ``:-'' as in
\begin{verbatim}
 head :- b1, ..., bN, not c1, ..., cN.
\end{verbatim}
The head consists of terms concatenated by a disjunction. For non disjunctive rules only one term is used.
The body is a comma separated conjunction of terms and their negation.
The variables used must be restricted to a domain in the body.
Check (\ref{domainrestricted}) to see the restrictions on domains.
\paragraph{Fact}
A rule can occur without a body as a fact, therefore the body is omitted.
\begin{verbatim}
 head.
\end{verbatim}
\paragraph{Integrity Constraint}
To express an integrity constraint, a rule with an empty body is used.
\begin{verbatim}
 :- body.
\end{verbatim}

\subsection{Advanced Language Features}
To ease the process of writing logic programs some advanced features in the input syntax are introduced and are now explained in detail.
For the most problems it is possible to write a much shorter and sometimes even faster version of the program with the extended syntax.
%Even a speedup in solving the instances of the problem can happen TODO ?
For a full syntax description in EBNF see appendix (\ref{appendix}).
\paragraph{Function Symbols}
Function symbols are fully supported with gringo.
They can be finitely nested and also be used as domain predicates.
While in lParse function symbols are allowed in a very restricted way, no restrictions apply in gringo.
The following program can not be grounded with lParse since $X$ is an unrestricted variable. With gringo the program is now groundable.
\begin{verbatim}
a(X) :- f(1,g(X)).
f(1,X) :- f(X).
f(g(2)).
\end{verbatim}
From the second rule the domain \texttt{f(1,g(2))} is generated.
This domain can be used for the first rule and results in the grounded rule
\begin{verbatim}
 a(2) :- f(1,g(2)).
\end{verbatim}

\paragraph{Range Operator}
To define several atoms that stretch on one or more parameters over a certain range, two dots can be used to express an increasing integer range.
Using the range operator in the head of a rule, it works as a conjunction of all the members in the range, so for every number the rule is duplicated.
\begin{verbatim}
 times(1..3, 1..2).
\end{verbatim}
will result in the facts
\begin{verbatim}
 times(1,1). times(2,1). times(3,1).
 times(1,2). times(2,2). times(3,2).
\end{verbatim}

Using the range operator in the body of a rule, a disjunction of all members in the range is created. So the rules will be duplicated for every member.
\begin{verbatim}
 a :- p(1..3).
\end{verbatim}
will result in the rules
\begin{verbatim}
 a :- p(1).
 a :- p(2).
 a :- p(3).
\end{verbatim}
If the range operator is used in an aggregate, it creates a comma separated list of atoms, so
\begin{verbatim}
 a :- {b(1..3)}.
\end{verbatim}
results in
\begin{verbatim}
 a :- {b(1), b(2), b(3)}.
\end{verbatim}

\paragraph{Expander :}
With the expander ``:'' a domain can be set.
On the left side of the operator an atom with variables is expected and on the right side the domains for the variables are given.
In the head, the atoms get connected via a disjunction, in the body they get connected via a conjunction, so no new rules are created with this operator.
\begin{verbatim}
 a(X,Y) : b(X) : c(Y) :- d(X) : e(X).
 b(1..2).
 c(3).
 e(a;b;c).
\end{verbatim}
would become
\begin{verbatim}
 a(1,3) | a(2,3) :- d(a), d(b), d(c).
\end{verbatim}
This operator can be used in aggregates to create a comma separated list of atoms.
For example
\begin{verbatim}
 n(1..9).
 1{a(X) : n(X) : X > 3}1.
\end{verbatim}
would become
\begin{verbatim}
 1 {a(4), a(5), a(6), a(7), a(8), a(9)} 1.
\end{verbatim}

\paragraph{Conjunctor ;}
The conjunctor ``;'' will create a conjunction of its elements.
Used in the head of a rule means that the rule is duplicated.
If used in the body instead, the atoms will be logically combined using a conjunction.
\begin{verbatim}
 a(X;1..2) :- b(X;a;b).
 b(foo). b(bar).
\end{verbatim}
will results in the rules\footnote{gringo would simplify the grounded rules since some literals in the body are facts}
\begin{verbatim}
 a(foo) :- b(foo), b(a), b(b).
 a(bar) :- b(foo), b(a), b(b).
 a(1)   :- b(bar), b(a), b(b).
 a(2)   :- b(bar), b(a), b(b).
\end{verbatim}
The conjunctor can not be used directly in aggregates, but for example in combination with the expander.
\begin{verbatim}
 { a(X,Y) : p(X;Y) }.
 p(1..2).
\end{verbatim}
Results in
\begin{verbatim}
 {a(1,1), a(1,2), a(2,1), a(2,2)}.
 p(1).
 p(2).
\end{verbatim}

\paragraph{Arithmetic Expressions}
The built-in arithmetics can be used for integer arithmetic.
As operators addition (+), subtraction (-), multiplication (*), division (/), modulo (mod) and the absolute value operator (abs) can be used.
Furthermore the bitwise operators and(\&), or(?), xor(\textasciicircum) and invert($\sim$) are supported. The bitwise operators are executed on signed integers using the binary complement for negative numbers.
Arithmetic expressions can occur everywhere in the head and in the body, even in complex constructs.
As parameters, integer constants or expressions that evaluate to integers are used.
The simple example of using operators and range terms
\begin{verbatim}
 a(X-1 .. X+1) :- b(X,Y), c(abs(Y * 2 * -X)).
 b(1,2).
 c(4).
\end{verbatim}
would result in the grounded program
\begin{verbatim}
 a(0) :- b(1,2), c(4).
 a(1) :- b(1,2), c(4).
 a(2) :- b(1,2), c(4).
 b(1,2).
 c(4).
\end{verbatim}

\subparagraph{Relational Operators}
The relational operators are ``less than'' ($<$), ``greater than'' ($>$), ``less equal'' ($<=$), ``greater equal'' ($>=$) , ``equal'' ($==$) and ``not equal'' ($!=$).
They can be used to constrain certain variables.
For example, the following rule is only generated for all unifications where $X$ is greater or equal $Y-1$.
\begin{verbatim}
 a(X) :- b(X,Y), X >= Y-1.
 b(0,2).
 b(4,2).
\end{verbatim}
This would let $\texttt{b(4,2)}$ be a valid substitution, since $4 >= 2-1$ but $\texttt{b(0,2)}$ not, so the grounded program could be:
\begin{verbatim}
 a(4) :- b(4,2).
 b(0,2).
 b(4,2).
\end{verbatim}

\subparagraph{Assignment Operator}
As assignment operator ``$=$'' is used.
The variable on the left side is set to the value of the right side.
\begin{verbatim}
 a(X) :- X=Y*2, b(Y).
 b(1..2).
\end{verbatim}
becomes
\begin{verbatim}
 a(2) :- b(1).
 a(4) :- b(2).
 b(1..2).
\end{verbatim}
A cyclic assignment that results in an unbound variable is not allowed and is rejected with an error . For example
\begin{verbatim}
 a(X) :- X=Y, Y=X.
\end{verbatim}
Furthermore the assignment operator can be used with aggregates. The program
\begin{verbatim}
 price(apple,5). prices(banana, 6). price(computer, 100).
 fruit(apple).
 fruit(banana).
 max_cost(1..200).
 costs(C) :- C = [price(X,Y) : fruit(X) : max_cost(Y) = Y].
\end{verbatim}
would lead to the fact \texttt{costs(11)} as the price of all fruits.
$C$ in this example becomes all values that have to be generated for the aggregate.

\paragraph{Classical Negation}
For classical negation the atom is preceded by a minus sign.
\begin{verbatim}
 -a :- not  a.
  a :- not -a. 
\end{verbatim}
\paragraph{Disjunction}
A disjunction can be expressed using the pipe symbol ``$\mid$''.
A disjunction can only occur in the head of a rule.
\begin{verbatim}
 red | green | blue :- colored.
\end{verbatim}
Using disjunctions in logic programs can increase expressiveness and complexity of the logic program.
A solver for disjunctive logic programs such as claspD \cite{claspD} or cmodels \cite{cmodels} is needed to solve such programs. Clingo is currently not able to solve disjunctive programs.

\paragraph{Aggregates}
An aggregate is a set or a multiset of atoms and has a lower and an upper bound.
The general syntax is
\begin{verbatim}
 lower aggregate_name [atom1=w1, ..., atomN=wN] upper
\end{verbatim}
If squared brackets are used, the atom list is interpreted as a multiset, otherwise, for curly brackets, as a set of atoms.
The lower and upper bound is optional, and can be omitted. The supported aggregates are
\begin{verbatim}
 0 count {a, b, not c} 2.
 1 sum [a=1, b=3, not c=-2] 2.
 0 max [a=1, b=2, not c=3] 5.
 1 min [a=2, b=4, not c=1] 3.
\end{verbatim}
and are now explained in detail.

\subparagraph{Count}
A ``count'' aggregate is a set of atoms and has an optional lower and upper bound.
It evaluates to true if the number of true atoms in the set is between the lower and upper bound. Only curly brackets may be used for a count aggregate as it represents a set of atoms.
Weights are not allowed in the count aggregate.
For this aggregate a shorthand syntax exists
\begin{verbatim}
 lower {atom1, ..., atomN} upper
\end{verbatim}
The count aggregate is equal to the cardinality constraint known from smodels \cite{smodels}.
\subparagraph{Sum}
The ``sum'' aggregate is a multiset of weighted atoms and has an optional lower and upper bound. It evaluates to true if the sum of the weights of all true atoms in the multiset is between the lower an upper bound.
The sum aggregate is equal to the weight constraints known from smodels, and has therefore a shorthand syntax
\begin{verbatim}
 lower [atom1=w1, ..., atomN=wN] upper
\end{verbatim}
If the command line option ``-l'' is used the semantic may change if negative weights exist in the aggregate. The transformation used is described in \cite{lparseManual}.

\subparagraph{Min}
The ``min'' aggregate is determined by the minimum of all weights of atoms that evaluate to true.
For the minimum aggregate a multiset with weighted atoms is used. It has no shorthand syntax.
\subparagraph{Max}
The ``max'' aggregate is similar to the minimum aggregate but considers the maximum of the weights.

\paragraph{Optimize Statements}

\subparagraph{Minimize/Maximize}
An optimize statement is used to find a minimal or maximal answer set of the logic program.
The statement can be weighted or not, therefore weights can be omitted in the following syntax.
\begin{verbatim}
 minimize [atom1 = w1, ..., atomN = wN].
\end{verbatim}
The maximize statement uses the keyword ``maximize'' instead.
If there were several minimize/maximize statements in the logic program the latter will be preferenced.
Only after the n'th statement results in the same value for two different answer set, the n-1'th statement is considered.


\subsection{Meta-Syntax}
This section is about constructs that do not originally belong to the logic program but can be used to give additional information for example to the solver.
The ``\#'' sign in front of all meta expressions is optional but is it strongly recommend to use it.
It separates the meta directives from the logic program more clearly and can prevent severe mistakes,
 confusing those constructs with atoms as shown in the example.
\begin{verbatim}
 hide.
 hidden :- hide.
\end{verbatim}
This program hides all predicates from the output of the ASP solver instead of deriving the facts \texttt{hide} and \texttt{hidden}.

\paragraph{hide and show}
The hide construct is used to hide atoms from the output of the ASP solver.
Two different syntaxes are supported by gringo.
The first 
\begin{verbatim}
 #hide name/arity.
\end{verbatim}
and the second
\begin{verbatim}
 #hide name(X1, ... , Xn).
\end{verbatim}
Both variants hide the predicate ``\texttt{name}''.
The arity of the predicate can be given explicit or implicit with a list of variables.
The variables are just placeholder and do not unify with other variables. For example \texttt{hide p(X,X)} would also hide the fact \texttt{p(a,b)}. The second syntax is implemented for compatibility reasons only.
If the predicate that has to be hidden has arity zero the syntax is
\begin{verbatim}
 #hide name.
\end{verbatim}
If you want to express that all but a few predicates shall be hidden the empty hide statement
in conjunction with the ``\texttt{show}'' statement can be is used.
With ``\texttt{show}'' all predicates are named that shall be visible.
So to hide all predicates but $p/3$ the following example can be used.
\begin{verbatim}
 #hide.
 #show p/3.
\end{verbatim}

\paragraph{const}
Within the ``\texttt{const}'' statement, a default value for constants can be defined in the logic program.
while they are normally defined via the command line options.
A default value for a constant $n$ can be easily be set.
\begin{verbatim}
 #const n=5.
\end{verbatim}
\paragraph{domain}
A domain statement states that a specific variable has a global domain restriction.
The statement
\begin{verbatim}
 #domain time(T).
\end{verbatim}
makes sure that the variable ``\texttt{T}'' is always bound to the domain of ``\texttt{time}''.
This has the same effect as adding the domain ``\texttt{time(T)}'' to every rule the variable ``\texttt{T}'' occurs in.
\paragraph{compute}
The compute statement is a hint for the solver which models to compute.
It has the syntax
\begin{verbatim}
 #compute number {a1, ..., aN, not aN+1, ..., not aM}.
\end{verbatim}
$number$ is the number of models that shall be computed by the answer set solver and can be omitted. If it is zero, no restriction to the number of models is applied.
All positive atoms in the compute statement must be in the computed models, and all negated atoms do not have to be in the models of the program.
The compute statement is solver dependent and not supported by every solver.
\paragraph{comments}
Two kinds of comments were supported by gringo.
Line based comments start with a ``\texttt{\%}''.
Whenever a ``\texttt{\%}'' occurs in the input, the rest of the line is treated as a comment and is therefore omitted.
Block based comments can span over several lines.
Everything between ``\texttt{\%*}'' and ``\texttt{*\%}'' is treated as a comment.
\subsection{Meta-Syntax for Incremental Programs}
\label{metasyntaxinc}
Incremental programs must be splitted into 3 parts.
The base part, for the information that hold in all steps and is independent of the incremental constant.
The cumulative part, where the cumulative rules must be set that hold in all steps, but depend on the incremental parameter.
And finally the volatile part. In this part the queries to the program are given, that must hold only in the last state.
To separate the parts, three statements exists. Everything beyond such a statement is considered to belong to the specific part.
To start the base part
\begin{verbatim}
 #base.
\end{verbatim}
must be written. Now all rules of the base part can follow.
The use of the incremental constant is not allowed in this part.
For the cumulative part an additional constant has to be passed to the statement.
\begin{verbatim}
 #cumulative k.
\end{verbatim}
Now all incremental rules follow. The incremental constant used for grounding is $k$.
The same holds for the volatile part.
\begin{verbatim}
 #volatile k.
\end{verbatim}
The ``\#''-sign can not be omitted for these meta statements.
These statements can also be mixed, only the last statement is important.
If no statement is given at the beginning of the file, base is assumed.


\section{Examples}
In this section some encodings for common problems are presented and explained.

\subsection{How to Write a Logic Program}
Writing a logic program to solve a problem is rather describing a problem than describing an algorithm to solve a problem.
Therefore the problem must be encoded as a set of rules.
Typically these are divided into a problem description and an instance of the problem.
The solution to a problem can then be read from the answer sets of the program.
The procedure of writing a logic program shall now be explained with a little example.
We want to write a problem encoding for the 3-colorability problem of graph coloring.
Given an arbitrary graph, no two connected edges may have the same color.
The most common technique is the ``generate \& test'' approach. Therefore, in the generator, rules are created that can derive a superset of the solution to the problem. In the tester all solutions that do not fit the constraints are omitted.
\newline
Usually you start with the generator.
At first, we define the non instance domains, in our example the colors we use.
\begin{verbatim}
 color(red). color(green). color(blue).
\end{verbatim}
Now we have to color all the vertices, but we must give attention that each vertex has only one color.
We can do this by simply saying that a vertex $V$ is colored with one color $C$, and that the same vertex does not have any of the other colors $D$ or $E$.
\begin{verbatim}
 colored(V,C) :- not colored(V,D), not colored(V,E),
                 C != D, C != E, D != E,
                 color(E), color(C), color(D), vertex(V).
\end{verbatim}
As you can see, you have to give the domain of the variables in the rule.
The variable $V$ is used for vertices and the variables $C$, $D$ and $E$ are used for colors.
After every vertex now has a color we would get all possible solutions of all vertices colorfully painted.
We now need to restrict our solutions in the tester by saying that two vertices that are connected by an edge should not have the same color.
We can do this by using an integrity constraint.
An integrity constraint is a rule with an empty head, and if an assignment of variables fulfills the body, the assignment is not a solution of our problem.
\begin{verbatim}
 :- edge(V,U), colored(V,C), colored(U,C).
\end{verbatim}
Here we have the edge between two vertices $V$ and $U$, and if both are colored with the same color $C$ the assignment is not a solution to our problem.
\newline
We have finally written our problem description, all we need now is a problem instance. This step is fairly simple.
We just need to define several vertices and edges that do connect the vertices.
For the following simple graph
\[
 \xymatrix{1\ar@{-}[dr]\ar@{-}[d]\ar@{-}[r]&2\ar@{-}[dl]\\
           3&4}
\]

we could just write
\begin{verbatim}
 vertex(1..4).
 edge(1,2). edge(1,4).
 edge(3,1). edge(3,2).
\end{verbatim}

If we give the problem description and the instance to the grounder, it will generate a variable free version of the problem. This can then be solved by a solver and in the answer sets of the solver the ``\texttt{colored/2}'' predicate states a valid coloring of all vertices.
We can do this by simply using the internal interface to clasp, to get a solution.
\begin{verbatim}
 ./clingo 3colorability.lp instance1.lp
\end{verbatim}
In the first answer set we find the ``\texttt{colored}'' predicates
\begin{verbatim}
 colored(1,green) colored(2,red) colored(3,blue) colored(4,red)
\end{verbatim}
and we can interpret them as the colors of the vertices
 
\[
 \xymatrix{\color{green}1\ar@{-}[dr]\ar@{-}[d]\ar@{-}[r]&\color{red}2\ar@{-}[dl]\\
           \color{blue}3&\color{red}4}
\]
To improve the readability of the answer set, all but the \texttt{colored/2} predicates can be hidden with these two lines.
\begin{verbatim}
 #hide.
 #show colored/2.
\end{verbatim}


\subsection{How to Write an Incremental Program}
As in writing a non incremental logic problem, we describe a problem rather than an algorithm.
The difference between a non incremental and an incremental program is that we can use an incremental constant.
This constant is set to zero at the beginning and the solver tries to find a solution of the problem. If it can not find a solution it starts to increment the constant by one. At each step the solver searches for a solution to the problem and increments the constant until he finds a valid answer set for the logic program.
The incremental constant can therefore be used among other things to emulate time steps.
For example, if the solution for a planning problem can not be found in 3 steps, it is tried to find one in more steps.
To make it concrete, an incremental encoding for the blocksworld problem is presented.
This is a very simple problem, where $n$ blocks are stacked on top of each other and you can move only one block at the same time. The goal is to stack the blocks in the inverse order.
Since an incremental logic program is divided into three parts, we start with the base part.
All rules that hold in all time steps that are independent of the incremental constant are put here.
At first we declare $n$ blocks and that each block is a location where a block can be put on.
Furthermore we define an extra location, the table. That is the location where the bottom most block is put.
\begin{verbatim}
 #base.

 block(1..n).
 location(X) :- block(X).
 location(table).
\end{verbatim}
Now we stack all blocks on top of each other, so block 1 is on block 2, block 2 is on block 3 etc.
The last block we put on the table.
This all holds in the initial state, so a $0$ is appended to the ``\texttt{on}'' predicate.
\begin{verbatim}
 on(X,X+1,0) :- block(X), X < n.
 on(n,table,0).
\end{verbatim}
After declaring the base part and describing the initial situation we have to describe valid moves for the blocks. This is done in the cumulative part, since moves can be done in each step. For the incremental constant we choose the name ``\texttt{k}''.
At first we want to execute at least one move every step, but not more than one. This can be done with a cardinality constraint.
\begin{verbatim}
 #cumulative k.

 1{move(X,Y,k) : block(X) : location(Y) : X != Y}1.
\end{verbatim}
A move is of the form ``\texttt{move(X,Y,k)}'' where \texttt{X} is the block that is moved, \texttt{Y} the new position of the block and \texttt{k} the step when the moved is executed.
\newline
Now that we have exactly one move per step we need to define what happens if we move a block.
Understandably if we move block \texttt{X} to position \texttt{Y} in step \texttt{k}, the new location of the block shall be \texttt{Y}.
\begin{verbatim}
 on(X,Y,k) :- move(X,Y,k).
\end{verbatim}
For all other blocks that have not moved, the position shall be the same.
In ASP a little trick is used to describe such a condition.
We first define a little helper predicate that states that a block has moved.
\begin{verbatim}
 moved(X, k) :- move(X, Y, k).
\end{verbatim}
With this helping predicate we can define that a block is on the same position in step \texttt{k}, if it was not moved.
\begin{verbatim}
 on(X,Y,k) :- on(X,Y,k-1), block(X), location(Y), not moved(X,k).
\end{verbatim}

Now we have to restrict our moves, because only one block can be moved at the same time and it can only be moved if no other block is on top of it.
First we introduce a predicate called ``\texttt{blocked}'' for each block with another block on top of it.
\begin{verbatim}
 blocked(Y, k) :- block(Y), on(X, Y, k - 1).
\end{verbatim}
Now we can restrict the moves with an integrity constraint.
\begin{verbatim}
 :- move(X, Y, k), blocked(X, k).
\end{verbatim}
So it is not allowed to move block \texttt{X} in step k, if it is blocked.
Also you can not move a block to a position where another block is on, so only one block on top of another is allowed.
\begin{verbatim}
 :- move(X, Y, k), blocked(Y, k).
\end{verbatim}
The description of the problem is nearly finished. All that has to be done is to formulate a query.
As a constraint to our solution we want to stop if all blocks are on top of each other in reversed order.
This query shall only hold in the last step, therefore we write it in the volatile part.
As always for constraints, we use an integrity constraint to express that all solutions are false where there is not block $n+1$ on the block $n$.
\begin{verbatim}
 #volatile k.

 :- not on(X+1,X,k), block(X), X < n.
\end{verbatim}
To run this example, iclingo has to be used and the constant $n$ has to be set via command line.
A potential command line call could look like
\begin{verbatim}
 iclingo --const n=10 blocksworld.lp
\end{verbatim}
and the answer to the problem can be read from the answer set.
To clean up the answer the ``\texttt{show} and \texttt{hide}'' feature of gringo can be used.
If the following lines were added to the program, the answer set only consists of \texttt{move/3} predicates.
\begin{verbatim}
 #hide.
 #show move/3.
\end{verbatim}


\section{Using Gringo}
\subsection{Command Line Interface}
All gringo tools can be downloaded as binary from \cite{download}. To build them from source, an installation guide ``INSTALL'' is included in the tar file.
The gringo tools can be started from the command line and have some parameters that can be useful.
All programs are fully backward compatible meaning, all options of gringo are valid in clingo and iclingo, and all options of clingo are valid in iclingo.
\subsection{Gringo Options}
Gringo can be called from the command line via
\begin{verbatim}
 gringo (gringo option|file)*
\end{verbatim}
If no filename is given, the standard input is used.

\paragraph{\texttt{--help,-h}}
Gives a short overview of all parameters.
\paragraph{\texttt{--version,-v}}
Prints the version information and exists.
\paragraph{\texttt{--verbose,-V}}
Prints additional information during processing.
\paragraph{\texttt{--syntax}}
Prints a short description of the syntax of the input language.
\paragraph{\texttt{--stats}}
Prints extended statistic information.

\paragraph{\texttt{--text,-t}}
Parameter ``\texttt{--text}'' invokes the text output method, so the output is printed in human readable format, which is also the input format for gringo. The output is variable free and some simplifications on the program were made. To convert a variable free program in plain format into a format readable by a solver use the \texttt{--ground} option.
\paragraph{\texttt{--lparse,-l}}
This mode prints lParse conform output. For a definition of the output format see \cite{lparseManual}.
Since some features of gringo are not natively supported for this output language, new atoms may be introduced to create an equivalent program.\newline
Sum aggregates with negative weights are handled like weight constraint in lParse for this output format. So a transformation as explained in \cite{lparseManual} is used to get rid of the negative weights.
\paragraph{\texttt{--aspils,-a 1-7}}
This parameter invokes the new output format for the intermediate language ASPils \cite{gejaosscth08b}. The optional number can range from $1$ to $7$ and refers to one of the following normal forms (Simple=1, SModels=2, DisjunctiveLogicProgram=3, CModels=4, CModelsExtended=5, DLV=6, Conglomeration=7).
% If no normal form is specified, conglomeration(7)  is assumed.

\paragraph{\texttt{--ground,-g}}
If this parameter is used, gringo expects an already grounded program as input.
For converting an already grounded logic program into an output format 
supported by gringo this is the right option.
 This mode saves a lot of memory but does not ground the program.
\paragraph{\texttt{--const,-c C=v}}
You can set the value of constants defined in your logic program via the command line of gringo.
After the parameter ``--const'' you have to give the name of the constant $C$ you want to set followed by a ``$=$'' and the value of that constant. The integer value $v$ can even be an arithmetic expression. For example:
\begin{verbatim}
 gringo --const n=5*2
\end{verbatim}
the constant $n$ is replaced by $10$ in the logic program.
\paragraph{\texttt{--bindersplitting=<arg>}}
With this option you can enable or disable the binder splitting used by gringo.
\begin{itemize}
 \item yes : Enable binder splitting
 \item no  : Disable binder splitting
\end{itemize}
\paragraph{\texttt{--ifixed=<num>}}
An incremental program is required as input. Gringo grounds the fixed number of steps of the incremental program.

\paragraph{Default Parameters}
The default command line is
\begin{verbatim}
 gringo --lparse --bindersplitting=yes
\end{verbatim}
to read from standard input and for smodels output.

\subsection{Clingo Options}

Clingo can be called from the command line via
\begin{verbatim}
 clingo (clingo option|file)*
\end{verbatim}
If no filename is given, the standard input is used.
Since clingo uses gringo as a grounder in combination with the solver clasp, all options from gringo and clasp are valid. For a detailed list of the clasp options see the clasp help (also available with \texttt{clingo --help}).
\paragraph{\texttt{--clasp,-C}}
In this mode, the output is directly parsed to clasp. For solving logic programs, no intermediate files are produced and the answer sets are printed directly.
With this option enabled, all parameters for clasp are valid and can be declared in the command line.
For example:
\begin{verbatim}
 clingo --clasp --const n=5 --supp-models 3
\end{verbatim}
Furthermore all restriction on smodels output hold, as clasps internal interface currently reads smodels format.
This is default for clingo.
\paragraph{\texttt{--solveonly=<arg>}}
This option can be used to set the working mode of clingo to use it as a solver only.
\begin{itemize}
\item yes : Pass input directly to clasp
\item no : Standard mode
\end{itemize}
The default is \texttt{--solveonly=no} to ground the logic program first.
If the input shall directly be passed to clasped, it has to be in the valid smodels input format.

\paragraph{Default Parameters}
The default is to read from standard input and search for one model.
\begin{verbatim}
 clingo 1 --clasp --solveonly=no
          --trans-ext=no --eq=5 
          --lookahead=no --lookback=yes --heuristic=Berkmin
          --rand-prop=0.0 --randomize=no --rand-watches=yes
          --restarts=100,1.5 --deletion=3,1.1,3.0
          --minimize=all --contraction=250 --loops=common
\end{verbatim}

\subsection{Iclingo Options}
Iclingo can be called from the command line via
\begin{verbatim}
 iclingo (iclingo option|file)*
\end{verbatim}
Iclingo is used for incremental solving. For a detailed description see \cite{gekaosscth08a}.
It uses the grounder gringo and the solver clasp, and therefore all options of gringo, clingo and clasp are valid.
Additionally some options for controlling the incremental behavior are implemented.
\paragraph{\texttt{--incremental,-i}}
Activates the incremental solving. This is the default for iclingo.
\paragraph{\texttt{--istats}}
Prints additional statistics for each incremental step.
\paragraph{\texttt{--imin=<num>}}
At least \texttt{num} incremental steps are solved, whether an answer set has been found or not.
\paragraph{\texttt{--imax=<num>}}
At most \texttt{num} incremental steps are done. After them iclingo stops the search for answer sets.
\paragraph{\texttt{--iquery=<num>}}
With this option you can set in which steps you want to ground without solving.
Solving the incremental program starts after this step.

\paragraph{\texttt{--istop=<arg>}}
The stop condition during incremental solving can be set.
\begin{itemize}
 \item SAT    : Stop the search process if a solution was found.
 \item UNSAT  : Stop the search process if no solution was found.
\end{itemize}
The default for this option is SAT.
\paragraph{\texttt{--ilearnt=<arg>}}
This option influences the behavior of clasp when used incrementally.
\begin{itemize}
 \item keep   : Learnt nogoods are kept for the next step while solving.
 \item forget : Clasp forgets the learnt nogoods after each incremental step.
\end{itemize}
As default, clasp forgets the learnt nogoods.
\paragraph{\texttt{--iheuristic=<arg>}}
This option sets how to handle heuristic information during incremental solving.
\begin{itemize}
 \item keep   : Heuristic information is kept for the next step while solving.
 \item forget : Clasp forgets the heuristic information after each incremental step.
\end{itemize}
As default, clasp keeps the heuristic information gathered during the previous steps.
\paragraph{Default Parameters}
The default is to read from standard input and search for one model incrementally.
\begin{verbatim}
 iclingo 1 --incremental --istop=SAT --ilearnt=forget 
           --iheuristic=keep --trans-ext=no --eq=5 
           --lookahead=no --lookback=yes --heuristic=Berkmin
           --rand-prop=0.0 --randomize=no --rand-watches=yes
           --restarts=100,1.5 --deletion=3,1.1,3.0
           --minimize=all --contraction=250 --loops=common

\end{verbatim}


\subsection{Warnings}
Several warnings are produced by gringo to give hints on common mistakes.
They are all printed to standard error output.
TODO: Some new warnings and Errors were added lately by Roland

\begin{itemize}
 \item 
\begin{verbatim}
 "Warning: sum with negative bounds in the body of a rule"
\end{verbatim}
This warning occurs if a sum aggregate with negative weights has been found and the output format smodels is used or the output is redirected to clasp. In this format negative bounds are compiled away using the transformation described in \cite{lparseManual}. This may lead to counterintuitive results.
 \item 
\begin{verbatim}
 "Warning: multiple definitions of #const n"
\end{verbatim}
This warning is printed if more than one \#const statement is used to set the same constant.
The last attached value is used for grounding.
\item
\begin{verbatim}
 "Warning: p/3 is never defined"
\end{verbatim}
This warnings states that an atom is used in the body of a rule that never occurs in the head.
The predicate literal is given in the warning. The predicate will be removed through optimization.
\item
\begin{verbatim}
 "got ground program i hope u have enough memory :)"
\end{verbatim}
Use the command line option ``--ground'' to convert a ground program into another format.
For converting already ground programs to an output language a special module has been implemented that uses far less memory. Because trying to ground an already variable free program could need a huge amount of memory.
\item
\begin{verbatim}
 "Warning: There are no #base, #lambda or #delta sections."
\end{verbatim}
If writing an incremental program, the incremental sections\ref{metasyntaxinc} have to be used.
\item
\begin{verbatim}
 "Warning: There are statements not within a #base, #lambda"
 "         or #delta section."
 "         These Statements are put into the #base section."
\end{verbatim}
If writing an incremental program, all statements that are not written in an incremental section are automatically considered to belong to the \texttt{base} part of the program.
\item
\begin{verbatim}
 "Warning: Classical negation is not handled correctly in"
 "         combination with the incremental output."
 "         You have to add rules like:"
 "         :- a, -a. on your own! (at least for now)"
\end{verbatim}
To use classical negation in an incremental program the described rules have to be added manually. This will be fixed in a later version of gringo.
\end{itemize}
Furthermore all warnings from clasp are included.

\subsection{Errors}
Gringo stops the execution and prints an error message to standard error output.
\begin{itemize}
 \item 
\begin{verbatim}
 "the following rule cannot not be grounded,
  non domain predicates : { ... }"
\end{verbatim}
This error message gives a list of predicates that are not domain restricted.
You explicitly have to give a domain for those predicates.
 \item 
\begin{verbatim}
 "the following rule cannot not be grounded,
  weakly restricted variables: { ... }"
\end{verbatim}
This error message gives a list of variables that are not lambda restricted. 
\item
\begin{verbatim}
 "syntax error on line Y column Z unexpected token: X"
\end{verbatim}
The parser can not read the input format. Some unexpected token occurred in the input file.
\item
\begin{verbatim}
 "sorry clasp cannot handle disjunctive rules!"
\end{verbatim}
If using clingo or iclingo, this happens if disjunctive rules are used. Please choose another solver that support disjunctive rules.
\item
\begin{verbatim}
 "A fixed number of incremental steps is needed"
 "to ground the program."
\end{verbatim}
This error occurs if an incremental program is given to gringo without using the option \texttt{--ifixed} or iclingo.
\item
\begin{verbatim}
 "cyclic constant definition."
\end{verbatim}
A cyclic definition of a constant is not allowed as shown in the example.
\begin{verbatim}
 #const x=y.
 #const y=x.
\end{verbatim}
\item
\begin{verbatim}
 "The following statement cant be used with the"
 "incremental interface: X."
 "unsupported statement."
\end{verbatim}
It is not allowed to use an optimize (\texttt{minimize} or \texttt{maximize}) or \texttt{compute} statement in an incremental program.
\item
\begin{verbatim}
 "comparing different types"
 "comparing function symbols"
\end{verbatim}
This error occurs if trying to compare non compareable values or function symbols as in
\begin{verbatim}
 p :- 1 < s.
 p :- f(x) < f(y).
\end{verbatim}

\item
The next errors all belong to the ASPils output format.
Some constructs in the input language can not be expressed in certain normal forms.
Another normal form as to be chosen to support this feature.
\begin{verbatim}
 "Disjunction not allowed on this normal form,
  please choose normal form 2 or 4-7."
 "Count aggregate/cardinality constraint not allowed
  in this normal form,
  please choose normal form 3-7."
 "Count aggregate/cardinality constraint not allowed 
  with non trivial upper bound in this normal form,
  please choose normal form 5-7."
 "Count aggregate/cardinality constraint not allowed 
  with negative lower bound in this normal form,
  please choose normal form 5-7."
 "Sum aggregate/weight constraint not allowed
  in this normal form,
  please choose normal form 3-7."
 "Sum aggregate/weight constraint not allowed 
  with non trivial upper bound in this normal form,
  please choose normal form 5-7."
 "Sum aggregate/weight constraint not allowed 
  with negative lower bound in this normal form,
  please choose normal form 5-7"
 "Sum aggregate/weight constraint not allowed
  with negative weights in this normal form,
  please choose normal form 5 or 7."
 "Max aggregate not allowed in this normal form,
  please choose normal form 6 or 7."
 "Max aggregate not allowed
  with negative weights in this normal form,
  please choose normal form 7."
 "Min aggregate not allowed in this normal form,
  please choose normal form 6 or 7."
 "Min aggregate not allowed 
  with negative weights in this normal form,
  please choose normal form 7."
 "Optimize statement not allowed in this normal form,
  please choose normal form 3-7."
\end{verbatim}
%\begin{verbatim}
% "Times aggregate not allowed in this normal form."
% "Times aggregate not allowed
%  with negative weights in this normal form."
%\end{verbatim}
\end{itemize}


\section{Future Work}
Further research has to be done on features in the input language. Additionally the support of incremental grounding will be improved. To speed up the grounding process research on a bottom up grounding procedure is done. To support an even less restricted input language the support for $\Pi$-restricted programs is planned in a future release of gringo. For clingo, the results of research from claspD will lead to a new version of clingo, capable of handling disjunctive logic programs. All these features will lead to more acceptance of ASP-systems as the programs become easier to write and the bottleneck of ASP, the grounding part, will be faster.
Furthermore the acceptance of a standardized intermediate format for ASP is necessary. Gringo supports the ASPils output format, but many more tools for converting, shuffling and merging must be developed.
\newpage
\textbf{\appendixname}
\begin{appendix}
\section{EBNF Syntax}
\label{appendix}
\input{appendix}
\end{appendix}

\bibliographystyle{plain}
\bibliography{bibtex}
\appendix
\end{document}
